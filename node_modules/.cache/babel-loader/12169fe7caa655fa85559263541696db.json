{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ToWords = exports.DefaultToWordsOptions = exports.DefaultConverterOptions = exports.LOCALES = void 0;\n\nconst locales_1 = __importDefault(require(\"./locales\"));\n\nexports.LOCALES = locales_1.default;\nexports.DefaultConverterOptions = {\n  currency: false,\n  ignoreDecimal: false,\n  ignoreZeroCurrency: false,\n  doNotAddOnly: false\n};\nexports.DefaultToWordsOptions = {\n  localeCode: 'en-IN',\n  converterOptions: exports.DefaultConverterOptions\n};\n\nclass ToWords {\n  constructor(options = {}) {\n    this.options = {};\n    this.locale = undefined;\n    this.options = Object.assign({}, exports.DefaultToWordsOptions, options);\n  }\n\n  getLocaleClass() {\n    if (!(this.options.localeCode in locales_1.default)) {\n      throw new Error(`Unknown Locale \"${this.options.localeCode}\"`);\n    }\n\n    return locales_1.default[this.options.localeCode];\n  }\n\n  getLocale() {\n    if (this.locale === undefined) {\n      const LocaleClass = this.getLocaleClass();\n      this.locale = new LocaleClass();\n    }\n\n    return this.locale;\n  }\n\n  convert(number, options = {}) {\n    var _a;\n\n    options = Object.assign({}, this.options.converterOptions, options);\n\n    if (!this.isValidNumber(number)) {\n      throw new Error(`Invalid Number \"${number}\"`);\n    }\n\n    if (options.ignoreDecimal) {\n      number = Number.parseInt(number.toString());\n    }\n\n    let words = [];\n\n    if (options.currency) {\n      words = this.convertCurrency(number, options);\n    } else {\n      words = this.convertNumber(number);\n    }\n\n    if ((_a = this.locale) === null || _a === void 0 ? void 0 : _a.config.trim) {\n      return words.join('');\n    }\n\n    return words.join(' ');\n  }\n\n  convertNumber(number) {\n    var _a, _b, _c;\n\n    const locale = this.getLocale();\n    const isNegativeNumber = number < 0;\n\n    if (isNegativeNumber) {\n      number = Math.abs(number);\n    }\n\n    const split = number.toString().split('.');\n    const ignoreZero = this.isNumberZero(number) && locale.config.ignoreZeroInDecimals;\n    let words = this.convertInternal(Number(split[0]), true);\n    const isFloat = this.isFloat(number);\n\n    if (isFloat && ignoreZero) {\n      words = [];\n    }\n\n    const wordsWithDecimal = [];\n\n    if (isFloat) {\n      if (!ignoreZero) {\n        wordsWithDecimal.push(locale.config.texts.point);\n      }\n\n      if (split[1].startsWith('0') && !((_a = locale.config) === null || _a === void 0 ? void 0 : _a.decimalLengthWordMapping)) {\n        const zeroWords = [];\n\n        for (const num of split[1]) {\n          zeroWords.push(...this.convertInternal(Number(num), true));\n        }\n\n        wordsWithDecimal.push(...zeroWords);\n      } else {\n        wordsWithDecimal.push(...this.convertInternal(Number(split[1]), true));\n        const decimalLengthWord = (_c = (_b = locale.config) === null || _b === void 0 ? void 0 : _b.decimalLengthWordMapping) === null || _c === void 0 ? void 0 : _c[split[1].length];\n\n        if (decimalLengthWord) {\n          wordsWithDecimal.push(decimalLengthWord);\n        }\n      }\n    }\n\n    const isEmpty = words.length <= 0;\n\n    if (!isEmpty && isNegativeNumber) {\n      words.unshift(locale.config.texts.minus);\n    }\n\n    words.push(...wordsWithDecimal);\n    return words;\n  }\n\n  convertCurrency(number, options = {}) {\n    var _a, _b, _c, _d;\n\n    const locale = this.getLocale();\n    const currencyOptions = (_a = options.currencyOptions) !== null && _a !== void 0 ? _a : locale.config.currency;\n    const isNegativeNumber = number < 0;\n\n    if (isNegativeNumber) {\n      number = Math.abs(number);\n    }\n\n    number = this.toFixed(number); // Extra check for isFloat to overcome 1.999 rounding off to 2\n\n    const split = number.toString().split('.');\n    let words = [...this.convertInternal(Number(split[0]))]; // Determine if the main currency should be in singular form\n    // e.g. 1 Dollar Only instead of 1 Dollars Only\n\n    if (Number(split[0]) === 1 && currencyOptions.singular) {\n      words.push(currencyOptions.singular);\n    } else if (currencyOptions.plural) {\n      words.push(currencyOptions.plural);\n    }\n\n    const ignoreZero = this.isNumberZero(number) && (options.ignoreZeroCurrency || ((_b = locale.config) === null || _b === void 0 ? void 0 : _b.ignoreZeroInDecimals) && number !== 0);\n\n    if (ignoreZero) {\n      words = [];\n    }\n\n    const wordsWithDecimal = [];\n    const isFloat = this.isFloat(number);\n\n    if (isFloat) {\n      if (!ignoreZero) {\n        wordsWithDecimal.push(locale.config.texts.and);\n      }\n\n      const decimalPart = Number(split[1]) * (!locale.config.decimalLengthWordMapping ? Math.pow(10, 2 - split[1].length) : 1);\n      wordsWithDecimal.push(...this.convertInternal(decimalPart));\n      const decimalLengthWord = (_d = (_c = locale.config) === null || _c === void 0 ? void 0 : _c.decimalLengthWordMapping) === null || _d === void 0 ? void 0 : _d[split[1].length];\n\n      if (decimalLengthWord === null || decimalLengthWord === void 0 ? void 0 : decimalLengthWord.length) {\n        wordsWithDecimal.push(decimalLengthWord);\n      } // Determine if the fractional unit should be in singular form\n      // e.g. 1 Dollar and 1 Cent Only instead of 1 Dollar and 1 Cents Only\n\n\n      if (decimalPart === 1 && currencyOptions.fractionalUnit.singular) {\n        wordsWithDecimal.push(currencyOptions.fractionalUnit.singular);\n      } else {\n        wordsWithDecimal.push(currencyOptions.fractionalUnit.plural);\n      }\n    } else if (locale.config.decimalLengthWordMapping && words.length) {\n      wordsWithDecimal.push(currencyOptions.fractionalUnit.plural);\n    }\n\n    const isEmpty = words.length <= 0 && wordsWithDecimal.length <= 0;\n\n    if (!isEmpty && isNegativeNumber) {\n      words.unshift(locale.config.texts.minus);\n    }\n\n    if (!isEmpty && locale.config.texts.only && !options.doNotAddOnly && !locale.config.onlyInFront) {\n      wordsWithDecimal.push(locale.config.texts.only);\n    }\n\n    if (wordsWithDecimal.length) {\n      words.push(...wordsWithDecimal);\n    }\n\n    if (!isEmpty && !options.doNotAddOnly && locale.config.onlyInFront) {\n      words.splice(0, 0, locale.config.texts.only);\n    }\n\n    return words;\n  }\n\n  convertInternal(number, trailing = false) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;\n\n    const locale = this.getLocale();\n\n    if (locale.config.exactWordsMapping) {\n      const exactMatch = (_b = (_a = locale.config) === null || _a === void 0 ? void 0 : _a.exactWordsMapping) === null || _b === void 0 ? void 0 : _b.find(elem => {\n        return number === elem.number;\n      });\n\n      if (exactMatch) {\n        return [Array.isArray(exactMatch.value) ? exactMatch.value[+trailing] : exactMatch.value];\n      }\n    }\n\n    const match = locale.config.numberWordsMapping.find(elem => {\n      return number >= elem.number;\n    });\n    const words = [];\n\n    if (number <= 100 || number < 1000 && locale.config.namedLessThan1000) {\n      words.push(Array.isArray(match.value) ? match.value[0] : match.value);\n      number -= match.number;\n\n      if (number > 0) {\n        if ((_d = (_c = locale.config) === null || _c === void 0 ? void 0 : _c.splitWord) === null || _d === void 0 ? void 0 : _d.length) {\n          words.push(locale.config.splitWord);\n        }\n\n        words.push(...this.convertInternal(number, trailing));\n      }\n\n      return words;\n    }\n\n    const quotient = Math.floor(number / match.number);\n    const remainder = number % match.number;\n    let matchValue = Array.isArray(match.value) ? match.value[0] : match.value;\n\n    if (quotient > 1 && ((_f = (_e = locale.config) === null || _e === void 0 ? void 0 : _e.pluralWords) === null || _f === void 0 ? void 0 : _f.find(word => word === match.value)) && ((_g = locale.config) === null || _g === void 0 ? void 0 : _g.pluralMark)) {\n      matchValue += locale.config.pluralMark;\n    }\n\n    if (quotient % 10 === 1) {\n      matchValue = match.singularValue || (Array.isArray(matchValue) ? matchValue[0] : matchValue);\n    }\n\n    if (quotient === 1 && ((_j = (_h = locale.config) === null || _h === void 0 ? void 0 : _h.ignoreOneForWords) === null || _j === void 0 ? void 0 : _j.includes(matchValue))) {\n      words.push(matchValue);\n    } else {\n      words.push(...this.convertInternal(quotient, false), matchValue);\n    }\n\n    if (remainder > 0) {\n      if ((_l = (_k = locale.config) === null || _k === void 0 ? void 0 : _k.splitWord) === null || _l === void 0 ? void 0 : _l.length) {\n        if (!((_o = (_m = locale.config) === null || _m === void 0 ? void 0 : _m.noSplitWordAfter) === null || _o === void 0 ? void 0 : _o.find(word => word === match.value))) {\n          words.push(locale.config.splitWord);\n        }\n      }\n\n      words.push(...this.convertInternal(remainder, trailing));\n    }\n\n    return words;\n  }\n\n  toFixed(number, precision = 2) {\n    return Number(Number(number).toFixed(precision));\n  }\n\n  isFloat(number) {\n    return Number(number) === number && number % 1 !== 0;\n  }\n\n  isValidNumber(number) {\n    return !isNaN(parseFloat(number)) && isFinite(number);\n  }\n\n  isNumberZero(number) {\n    return number >= 0 && number < 1;\n  }\n\n}\n\nexports.ToWords = ToWords;","map":null,"metadata":{},"sourceType":"script"}